// Copyright: This file is part of korrel8r, released under https://github.com/korrel8r/korrel8r/blob/main/LICENSE

// package engine implements generic correlation logic to correlate across domains.
package engine

import (
	"context"
	"fmt"
	"strings"

	"github.com/korrel8r/korrel8r/internal/pkg/logging"
	"github.com/korrel8r/korrel8r/pkg/graph"
	"github.com/korrel8r/korrel8r/pkg/korrel8r"
	"golang.org/x/exp/maps"
)

var log = logging.Log()

// Engine combines a set of domains and a set of rules, so it can perform correlation.
type Engine struct {
	domains       map[string]korrel8r.Domain
	stores        map[string][]korrel8r.Store
	rules         []korrel8r.Rule
	templateFuncs map[string]any
}

func New(domains ...korrel8r.Domain) *Engine {
	e := &Engine{
		domains:       map[string]korrel8r.Domain{},
		stores:        map[string][]korrel8r.Store{},
		templateFuncs: map[string]any{},
	}
	for _, d := range domains {
		e.domains[d.String()] = d
		e.addTemplateFuncs(d)
	}
	return e
}

// Domain returns the named domain or nil if not found.
func (e *Engine) Domain(name string) korrel8r.Domain  { return e.domains[name] }
func (e *Engine) Domains() map[string]korrel8r.Domain { return e.domains }
func (e *Engine) DomainErr(name string) (korrel8r.Domain, error) {
	if d := e.Domain(name); d != nil {
		return d, nil
	}
	return nil, korrel8r.DomainNotFoundErr{Domain: name}
}

// StoresFor returns the known stores for a domain.
func (e *Engine) StoresFor(d korrel8r.Domain) []korrel8r.Store { return e.stores[d.String()] }

// StoreErr returns the default (first) store for domain, or an error.
func (e *Engine) StoreErr(d korrel8r.Domain) (korrel8r.Store, error) {
	stores := e.StoresFor(d)
	if len(stores) == 0 {
		return nil, korrel8r.StoreNotFoundErr{Domain: d}
	}
	return stores[0], nil
}

// TemplateFuncser can be implemented by Domain or Store implementations to contribute
// domain-specific template functions to template rules generated by the Engine.
// See text/template.Template.Funcs for details.
type TemplateFuncser interface{ TemplateFuncs() map[string]any }

// AddStore adds a store. Error if the stores Domain is not registered with the engine.
func (e *Engine) AddStore(s korrel8r.Store) error {
	domain := s.Domain().String()
	if _, err := e.DomainErr(domain); err != nil {
		return err
	}
	e.stores[domain] = append(e.stores[domain], s)
	e.addTemplateFuncs(s)
	return nil
}

func (e *Engine) addTemplateFuncs(v any) {
	// Stores and Domains may implement TemplateFuncser if they provide template helper functions for rules
	if tf, ok := v.(TemplateFuncser); ok {
		maps.Copy(e.templateFuncs, tf.TemplateFuncs())
	}
}

// Class parses a full 'domain/class' name and returns the class.
func (e *Engine) Class(name string) (korrel8r.Class, error) {
	d, c, ok := strings.Cut(name, "/")
	if !ok || c == "" || d == "" {
		return nil, fmt.Errorf("invalid class name: %v", name)
	}
	domain, err := e.DomainErr(d)
	if err != nil {
		return nil, err
	}
	class := domain.Class(c)
	if class == nil {
		return nil, fmt.Errorf("unknown class in domain %v: %v", d, c)
	}
	return class, nil
}

func (e *Engine) Rules() []korrel8r.Rule { return e.rules }

func (e *Engine) AddRules(rules ...korrel8r.Rule) { e.rules = append(e.rules, rules...) }

// Graph creates a new graph of the rules and classes of this engine.
func (e *Engine) Graph() *graph.Graph { return graph.NewData(e.rules...).NewGraph() }

// TemplateFuncs returns template helper functions for stores and domains known to this engine.
// See text/template.Template.Funcs
func (e *Engine) TemplateFuncs() map[string]any { return e.templateFuncs }

// Get finds the store for the query.Class() and gets into result.
func (e *Engine) Get(ctx context.Context, class korrel8r.Class, query korrel8r.Query, result korrel8r.Appender) error {
	for _, store := range e.StoresFor(class.Domain()) {
		if err := store.Get(ctx, query, result); err != nil {
			return err
		}
	}
	return nil
}

func (e *Engine) Follower(ctx context.Context) *Follower { return &Follower{Engine: e, Context: ctx} }
