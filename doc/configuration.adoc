[id="configuration"]
= Configuration
:xref-domain: xref:index.adoc#index-domain-reference[Domain Reference]
:go-templates: https://pkg.go.dev/text/template[Go templates]
:pkg-korrel8r: https://pkg.go.dev/github.com/korrel8/korrel8/pkg/korrel8
:sprig: https://github.com/Masterminds/sprig[sprig]

include::attributes.adoc[]

Korrel8r loads configuration from the file specified by the `--config` flag:

[source,terminal]
----
$ korrel8r --config <path_to_config_file>
----

The default configuration can be loaded from the internet:
----
korrel8r -c https://raw.githubusercontent.com/korrel8r/korrel8r/main/etc/korrel8r/korrel8r.yaml get
----

[TIP]
====
You can examine the default configuration files at the Korrel8r project provides some link:{etc-korrel8r}[example configuration files]
====

The configuration file is a YAML file with the following sections:

[source,yaml]
.Include paths to other configuratoin files to include in this one.
----
include:
  - "path_to_config_file"
----

.Stores defines how to connect to data stores. See xref:_stores[].
[source,yaml]
----
stores:
  - domain: "domain_name" <1>
    # Domain-specific fields <2>
----

<1> Domain name of the store (required).
<2> Domain-specific fields for connection parameters. See {xref-domain}.

.Rules defines rules to relate different classes of data. See xref:_rules[].
[source,yaml]
----
rules:
  - name: "rule_name" <1>
    start: <2>
      domain: "domain_name"
      classes:
        - "class_name"
    goal: <3>
      domain: "domain_name"
      classes:
        - "class_name"
    result:
      query: "query_template" <4>
----

<1> Name identifies the rule in graphs and for debugging.
<2> Start objects for this rule must belong to one of the `classes` in the `domain`.
<3> Goal queries generated by this rule may must retrieve one of the `classes` in the `domain`.
<4> Result queries are generated by executing the `query` xref:_templates[template] with the start object as context.

.Aliases is a list of short-hand alias names for groups of rules.
[source,yaml]
----
aliases:
  - name: "alias_name" <1>
    domain: "domain_name" <2>
    classes: <3>
      - "class_name"
----

<1> Alias name can be used as a class name in rule definitions.
<2> Domain for classes in this alias.
<3> Classes belonging to this alias.

== Connecting to Stores

Every entry in the `stores` section has a `domain` field to identify the domain.
Other fields depend on the domain, see {xref-domain}.
Store fields can contain plain URL strings or xref:_templates[templates] that expand to URLs.

[source,yaml]
.Example: configuring a store URL from an Openshift Route resource.
----
stores:
  - domain: log
    lokiStack: <-
      {{$r := get "k8s:Route:{namespace: openshift-logging, name: logging-loki}" -}} <1>
      https://{{ (first $r).Spec.Host -}} <2>
----

<1> Get a list of routes in "openshift-logging" named "logging-loki".
<2> Use the .Spec.Host field of the first route as the host for the store URL.

== Writing Rules

Korrel8r comes with a good set of default rules, but you can modify them or add your own.

A rule has the following key elements:

* A set of _start_ classes. The rule can apply to objects belonging to one of these classes.
* A set of _goal_ classes. The rule can generate queries for any of these classes.
* A Go template to generate a goal query from a start object.
  See the section on xref:_templates[templates] below for more about writing rule templates.

The query template should generate a string of the form:

----
<domain-name>:<class-name>:<query-details>
----

The _query-details_ part depends on the domain, see {xref-domain}

.Example of rules and aliases.
[source,yaml]
----
TODO: Examples
----

== Templates

Some fields in the `stores` and `rules` section are {go-templates}.
Go template syntax is also used by the Kubernetes `kubectl` tool when run with the `--output=template` option.
Korrel8r provides additional _template functions_ to simplify writing rule and configuration templates.

.Additional template functions
- The {sprig} library of general purpose template functions is always available.
- Some domains provide additional functions, see {xref-domain}.

The following functions are always available:

query::
Executes its argument as a korrel8r query, returns []any.
May return an error.

// TODO: automate the above, get this from pkg/engine doc comments.
