# Makefile is self-documenting, comments starting with '##' are extracted as help text.
help: ## Print this help message.
	@echo; echo = Targets =
	@grep -E '^\w+:.*##' Makefile | sed 's/:.*##\s*/#/' | column -s'#' -t
	@echo; echo  = Variables =
	@grep -E '^## [A-Z_]+: ' Makefile | sed 's/^## \([A-Z_]*\): \(.*\)/\1#\2/' | column -s'#' -t

# The following variables can be overridden by environment variables or on the `make` command line

## VERSION: Explicitly set to a semantic version for release, generated using "git describe" for work in progress.
VERSION?=$(or dev-$(shell git describe 2>/dev/null | cut -d- -f1,2),$(file <$(VERSION_TXT)))
## IMG: Name of image to build or deploy, without version tag.
IMG?=quay.io/korrel8r/korrel8r
## TAG: Image tag, defaults to $(VERSION)
TAG?=$(VERSION)
## OVERLAY: Name of kustomize directory in config/overlays to use for `make deploy`.
OVERLAY?=dev
## IMGTOOL: May be podman or docker.
IMGTOOL?=$(shell which podman || which docker)

check: generate lint test ## Lint and test code.

all: check install _site image-build ## Build and test everything. Recommended before pushing.

clean: # Warning: runs `git clean -dfx` and removes checked-in generated files.
	rm -vrf bin _site $(VERSION_TXT) $(shell find -name 'zz_*')
	git clean -dfx

include tools.mk

VERSION_TXT=cmd/korrel8r/version.txt

ifneq ($(VERSION),$(file <$(VERSION_TXT)))
.PHONY: $(VERSION_TXT) # Force update if VERSION_TXT does not match VERSION
endif
$(VERSION_TXT):
	echo $(VERSION) > $@

generate: .generate.made
.generate.made: $(VERSION_TXT) pkg/api/zz_docs pkg/config/zz_generated.deepcopy.go $(shell find -name '*.go')  ## Generate code.
	hack/copyright.sh
	go mod tidy
	touch $@

pkg/config/zz_generated.deepcopy.go:  $(filter-out pkg/config/zz_generated.deepcopy.go,$(wildcard pkg/config/*.go)) bin/controller-gen
	bin/controller-gen object paths=./pkg/config/...

pkg/api/zz_docs: $(wildcard pkg/api/*.go pkg/korrel8r/*.go) bin/swag
	@mkdir -p $(dir $@)
	bin/swag init -q -g pkg/api/api.go -o $@
	bin/swag fmt pkg/api
	@touch $@

lint: $(VERSION_TXT) bin/golangci-lint ## Run the linter to find and fix code style problems.
	bin/golangci-lint run --fix

install: $(VERSION_TXT) ## Build and install the korrel8r binary locally in $GOBIN.
	go install -tags netgo ./cmd/korrel8r

test: ## Run all tests, requires a cluster.
	$(MAKE) TEST_NO_SKIP=1 test-skip
test-skip: $(VERSION_TXT) ## Run all tests but skip those requiring a cluster if not logged in.
	go test -timeout=1m -race ./...

cover: ## Run tests and show code coverage in browser.
	go test -coverprofile=test.cov ./...
	go tool cover --html test.cov; sleep 2 # Sleep required to let browser start up.

CONFIG=etc/korrel8r/korrel8r.yaml
run: $(VERSION_TXT) ## Run `korrel8r web` using configuration in ./etc/korrel8r
	go run ./cmd/korrel8r web -c $(CONFIG) $(ARGS)

IMAGE=$(IMG):$(TAG)
image-build: $(VERSION_TXT) ## Build image locally, don't push.
	$(IMGTOOL) build --tag=$(IMAGE) .

image: image-build ## Build and push image. IMG must be set to a writable image repository.
	$(IMGTOOL) push -q $(IMAGE)

image-name: ## Print the full image name and tag.
	@echo $(IMAGE)

IMAGE_KUSTOMIZATION=config/overlays/$(OVERLAY)/kustomization.yaml
.PHONY: $(IMAGE_KUSTOMIZATION)
$(IMAGE_KUSTOMIZATION):
	mkdir -p $(dir $@)
	hack/replace-image.sh "quay.io/korrel8r/korrel8r" $(IMG) $(TAG) > $@

WATCH=kubectl get events -A --watch-only& trap "kill %%" EXIT;

# NOTE: deploy does not depend on 'image', since it may be used to deploy pre-existing images.
# To build and deploy a new image do `make image deploy`
deploy: $(IMAGE_KUSTOMIZATION)	## Deploy to current cluster using kustomize.
	$(WATCH) kubectl apply -k config/overlays/$(OVERLAY)
	$(WATCH) kubectl wait -n korrel8r --for=condition=available --timeout=60s deployment.apps/korrel8r

undeploy:
	kubectl delete -k config/overlays/$(OVERLAY)

route:				## Create a route to access korrel8r service from outside the cluster, requires openshift.
	@oc delete -n korrel8r route/korrel8r --ignore-not-found
	@mkdir -p tmp
	@oc extract --confirm -n korrel8r configmap/openshift-service-ca.crt secret/korrel8r --to=tmp
	oc create route reencrypt -n korrel8r --service=korrel8r --cert=tmp/tls.crt --key=tmp/tls.key --dest-ca-cert=tmp/service-ca.crt --ca-cert=tmp/service-ca.crt
	$(MAKE) --no-print-directory route-url

route-url:			## Print the URL of the external route.
	@oc get -n korrel8r route/korrel8r -o template='https://{{.spec.host}}/'

# Public site is generated by .github/workflows/asciidoctor-ghpages.yml
ADOC_RUN=$(IMGTOOL) run -iq -v./docs:/src:z -v./_site:/dst:z quay.io/rhdevdocs/devspaces-documentation
ADOC_ARGS=-a revnumber=$(VERSION) -a stylesheet=fedora.css -D/dst /src/index.adoc
_site: $(wildcard docs/*.adoc) docs/zz_domains.adoc docs/zz_rest_api.adoc Makefile ## Generate the website HTML.
	@mkdir -p $@
	$(ADOC_RUN) asciidoctor $(ADOC_ARGS)
	$(ADOC_RUN) asciidoctor-pdf -a allow-uri-read -o ebook.pdf $(ADOC_ARGS)
	@touch $@
docs/zz_domains.adoc: $(shell find cmd/korrel8r-doc internal pkg -name '*.go')
	go run ./cmd/korrel8r-doc pkg/domains/* > $@
# Note docs/templates/markdown overrides the swagger markdown templates to generate asciidoc
docs/zz_rest_api.adoc: pkg/api/zz_docs docs/templates/markdown/docs.gotmpl bin/swagger
	bin/swagger -q generate markdown -T docs/templates -f $</swagger.json --output $@

release: release-check all release-commit release-push ## Create and push a new release tag and image. Set VERSION=vX.Y.Z.

release-check:
	@echo "$(VERSION)" | grep -qE "^v[0-9]+\.[0-9]+\.[0-9]+$$" || { echo "VERSION=$(VERSION) must be semantic version like vX.Y.Z"; exit 1; }
	@test -z "$(shell git status --porcelain)" || { git status -s; echo Workspace is not clean; exit 1; }

release-commit: release-check
	hack/changelog.sh $(VERSION) > CHANGELOG.md	# Update change log
	git commit -q  -m "Release $(VERSION)" -- $(VERSION_TXT) CHANGELOG.md
	git tag $(VERSION) -a -m "Release $(VERSION)"

release-push: release-check image
	git push origin main --follow-tags
	$(IMGTOOL) push -q "$(IMAGE)" "$(IMG):latest"
